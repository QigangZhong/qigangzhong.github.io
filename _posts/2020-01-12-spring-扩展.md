---
layout: post
title:  "spring 扩展"
categories: spring
tags: spring
author: 网络
---

* content
{:toc}











## 介绍

### SPI扩展

#### JDK的SPI机制

参考[SPI-ServieLoader](https://qigangzhong.github.io/2019/03/14/SPI-ServiceLoader/)

#### spring的SPI机制

跟JDK原生的SPI机制类似，但是使用的是SpringFactoriesLoader来解析META-INF/spring.factories

* spring.factories

* @EnableAutoConfiguration

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};

}
```

```java
public class AutoConfigurationImportSelector
        implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,
        BeanFactoryAware, EnvironmentAware, Ordered {
            //...
}
```

查看`@EnableAutoConfiguration`源码可以发现，它的核心在于`AutoConfigurationImportSelector`，关于@Import在spring-ioc容器中的加载时机，参考[这里](https://qigangzhong.github.io/2020/01/07/spring-ioc/#configuration%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B)。

它实现的是`DeferredImportSelector`，并且order=LOWEST_PRECEDENCE，也就是说它的加载优先级在所有配置类之后，详细分析一下它的核心方法`selectImports`

```java
AutoConfigurationImportSelector.selectImports
AutoConfigurationImportSelector.getCandidateConfigurations
//********************************************************
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata,
        AnnotationAttributes attributes) {
    //【这里使用了SpringFactoriesLoader来加载META-INF/spring.factories】
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(
            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
    Assert.notEmpty(configurations,
            "No auto configuration classes found in META-INF/spring.factories. If you "
                    + "are using a custom packaging, make sure that file is correct.");
    return configurations;
}
//********************************************************
```

自动配置的类在META-INF/spring.factories里面的key=`org.springframework.boot.autoconfigure.EnableAutoConfiguration`，可以参考spring-boot-autoconfigure包下面的META-INF/spring.factories文件配置。

当然这个是自动配置类的配置key，如果需要加载其它的自定义扩展类，key=接口名称，value=实现。

##### 自定义自动配置类

自定义的类上添加一些注解就可以，加载的顺序、条件同样可以参考spring-boot-autoconfigure包下面的META-INF/spring.factories文件配置里面内置的配置类

```java
@Configuration
@AutoConfigureAfter(JmxAutoConfiguration.class)
@ConditionalOnProperty(prefix = "spring.application.admin", value = "enabled", havingValue = "true", matchIfMissing = false)
@ConditionalOnClass({ EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class })
@ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)
```

### spring xml扩展

* spring.handlers

* spring.schemas定义了xml中namespace对应的xsd文件的本地位置

  * BeanDefinitionParser

  * NamespaceHandler/NamespaceHandlerSupport

#### 原理

从spring容器的入口方法AbstractApplicationContext.refresh开始

```java
AbstractApplicationContext#obtainFreshBeanFactory#refreshBeanFactory
AbstractRefreshableApplicationContext#refreshBeanFactory
AbstractXmlApplicationContext#loadBeanDefinitions
AbstractBeanDefinitionReader#loadBeanDefinitions
XmlBeanDefinitionReader#loadBeanDefinitions#doLoadBeanDefinitions
//【核心方法】加载XML文档
XmlBeanDefinitionReader#doLoadDocument
//【核心方法】从XML文档中解析BeanDefinition
XmlBeanDefinitionReader#registerBeanDefinitions
DefaultBeanDefinitionDocumentReader#registerBeanDefinitions#doRegisterBeanDefinitions
DefaultBeanDefinitionDocumentReader#parseBeanDefinitions
//*************************************************************
//这个方法比较关键，判断XML里面的namespace是不是默认的
//spring的XML配置里面所谓默认的namespace就是指 xmlns="http://www.springframework.org/schema/beans"
//自定义的namespace就是很多框架的扩展点，例如dubbo的spring配置就自定义了 “xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"”
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    //自定义扩展namespace在这里被解析
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        //自定义扩展namespace在这里被解析
        delegate.parseCustomElement(root);
    }
}
//*************************************************************
//对默认的namespace节点的处理逻辑，比如最常用的<beans xxx><bean xxx></bean></beans>节点
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }
    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }
    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }
    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        // recurse
        doRegisterBeanDefinitions(ele);
    }
}
//*************************************************************

//【我们把关注点聚焦在自定义namespace】
BeanDefinitionParserDelegate#parseCustomElement
//获取到所有的HandlerMappings，就是扫描所有依赖jar包META-INF/spring.handlers中定义的类，key=namespaceUrl，value=NamespaceHandler实现类
//获取META-INF/spring.handlers中内容的方法就是PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);
DefaultNamespaceHandlerResolver#resolve
DefaultNamespaceHandlerResolver#getHandlerMappings
//获取到META-INF/spring.handlers中定义的NamespaceHandler的map之后，根据节点的namespace字符串获取指定的NamespaceHandler来处理当前节点
//在NamespaceHandler中使用BeanDefinitionParser来解析XML节点
```

总结一下如何扩展spring的xml配置文件，添加自定义的xml标签及解析器，例如实现类似dubbo配置文件中的`<dubbo:xxx />`的解析

* 1、定义 xsd 文件
* 2、编写自定义NamespaceHandler，一般通过写一个类继承自NamespaceHandlerSupport
* 3、编写自定义BeanDefinitionParser，在自定义的NamespaceHandlerSupport子类中引用自定义的BeanDefinitionParser来解析XML节点
* 4、配置spring.handlers和spring.schmas，让spring能扫描到我们自定义的NamespaceHandler，在spring容器加载bean的过程中如果遇到自定义的XML节点就使用自定义的NamespaceHandler来处理这个节点

### springboot扩展-ApplicationContextInitializer

在ConfigurableApplicationContext初始化容器之前对容器进行操作

```java
//值越小越早执行
@Order(100)
public class MyApplicationContextInitializer implements ApplicationContextInitializer {
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        System.out.println("bean的数量：" + applicationContext.getBeanDefinitionCount());
    }
}
```

#### 三种使用方法

* SpringApplication.addInitializers()

```java
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        SpringApplication springApplication = new SpringApplication(App.class);
        springApplication.addInitializers(new MyApplicationContextInitializer());
        springApplication.run(args);
    }
}
```

* application.properties

```properties
context.initializer.classes=com.qigang.sb.ext.aci.MyApplicationContextInitializer
```

这个配置能生效主要靠`DelegatingApplicationContextInitializer`这个springboot内置的初始化器

* META-INF\spring.factories

```properties
org.springframework.context.ApplicationContextInitializer=com.qigang.sb.ext.aci.MyApplicationContextInitializer
```

这个是依赖spring的SPI机制

#### spring内置的初始化器

* DelegatingApplicationContextInitializer

加载application.properties或者环境变量中`context.initializer.classes`指定的自定义初始化器

* ContextIdApplicationContextInitializer
* ConfigurationWarningsApplicationContextInitializer
* ServerPortInfoApplicationContextInitializer

  既是一个ApplicationContextInitializer也是一个ApplicationListener，监听WebServerInitializedEvent事件，web服务器初始化后将端口写入到环境变量`local.server.port`中，然后程序中就可以通过`@Value("${local.server.port}")`或者`environment.getProperty("local.server.port")`来获取端口信息。

* SharedMetadataReaderFactoryContextInitializer
* ConditionEvaluationReportLoggingListener

### springboot扩展-SpringApplicationRunListener

参考[spring中的事件机制](https://qigangzhong.github.io/2019/12/17/spring-event/)

### springboot扩展-PropertySourceLoader

在spring-boot包的META-INF/spring.factories文件中配置了一系列`org.springframework.context.ApplicationListener`，其中有一个是`ConfigFileApplicationListener`，这个类里面包含了对`PropertySourceLoader`的操作，它在springboot中的默认实现也是通过META-INF/spring.factories来加载的

```java
//ConfigFileApplicationListener.Loader私有子类中
SpringFactoriesLoader.loadFactories(PropertySourceLoader.class, getClass().getClassLoader());
```

同样是在spring-boot包的META-INF/spring.factories里面有两个默认的`PropertySourceLoader`配置

```properties
org.springframework.boot.env.PropertySourceLoader=\
org.springframework.boot.env.PropertiesPropertySourceLoader,\
org.springframework.boot.env.YamlPropertySourceLoader
```

PropertiesPropertySourceLoader内部实际是通过`PropertiesLoaderUtils.loadProperties`来加载`.properties`配置文件的，默认的文件名称在`ConfigFileApplicationListener`里面定义的是`application`

## 参考

[spring利用spring.handlers解析自定义配置](https://www.jianshu.com/p/91f6068adff2)

[NamespaceHandler与自定义xml](https://my.oschina.net/u/2377110/blog/1186927)
