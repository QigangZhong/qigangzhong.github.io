---
layout: post
title:  "JVM内存模型"
categories: JVM
tags:  JVM
author: 网络
---

* content
{:toc}


## 前言

总结JVM相关的知识

##  课程目录
* JVM内存模型
* JVM内存模型与JMM之间的关系







### JVM

#### JDK,JRE,JVM之间的关系

![jdk.jpg](/images/jdk-jvm/jdk.jpg)

#### JVM内部结构

![jvm内部结构.png](/images/jdk-jvm/jvm内部结构.png)

> 注: 绿色部分是线程共享的区域，白色部分是线程私有的区域

#### 运行时数据区域介绍

a) 程序计数器(PC寄存器)

>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切　换　之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。

b) java栈

>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。　

![java_stack.png](/images/jdk-jvm/java_stack.png)

c) 本地方法栈

>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的

d) 堆

> Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。

e) 方法区

> 与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

> 在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。

> 在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，

> 对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

## 参考

[jvm内存模型和内存分配](https://www.cnblogs.com/fubaizhaizhuren/p/4976839.html)