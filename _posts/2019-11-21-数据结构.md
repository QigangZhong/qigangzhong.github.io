---
layout: post
title:  "数据结构"
categories: tools
tags:  数据结构
author: 网络
---

* content
{:toc}












## 二叉树

二叉树、平衡二叉树、红黑树

宽度优先搜索、深度优先搜索

### 深度、高度计算

前序遍历、中序遍历、后序遍历

```java
public int size()                                      //返回二叉树的结点数
{
    return size(root);
}

public int size(BinaryNode<T> p)                       //返回以p结点为根的子树的结点数
{
    if (p==null)
        return 0;
    return 1+size(p.left)+size(p.right);            //左右树分开求
}
```

```java
public int height()                                    //返回二叉树的高度
{
    return height(root);
}

public int height(BinaryNode<T> p) //返回以p结点为根的子树高度，后根次序遍历
{
    if (p==null)
        return 0;
    int lh = height(p.left);                           //返回左子树的高度
    int rh = height(p.right);                          //返回右子树的高度
    return (lh>=rh) ? lh+1 : rh+1;                //当前子树高度为较高子树的高度加1
}
```

### 二分查找

## 排序

一些常识：

1(mb)=1024(k)=1024×1024(B、字节、byte)=1024×1024×8(b、位、bit)

int类型占用4(B、字节)，也就是4×8=32(b、位)

* 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。
* 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）
* 字符：是指计算机中使用的字母、数字、字和符号
* ASCIIS码： 1个英文字母（不分大小写）= 1个字节的空间
* 1个中文汉字 = 2个字节的空间
* 1个ASCII码 = 一个字节
* UTF-8编码：1个英文字符 = 1个字节
* 英文标点 = 1个字节
* 1个中文（含繁体） = 3个字节
* 中文标点 = 3个字节
* Unicode编码：1个英文字符 = 2个字节
* 英文标点 = 2个字节
* 1个中文（含繁体） = 2个字节
* 中文标点 = 2个字节

### 快速排序

![quick_sort.jpg](/images/algorithm/quick_sort.jpg)

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr={ 6,1,2,7,9,3,4,5,10,8};
        quickSort(arr, 0,arr.length-1);
        for (int i:arr){
            System.out.println(i);
        }
    }

    private static void quickSort(int[] arr, int start, int end){
        if(start>end){
            return;
        }

        //i:左边的哨兵, j:右边的哨兵, flag:基准数字,一般设置为左边第一个数字
        int i,j,flag;
        //flag中存的就是基准数
        flag=arr[start];
        i=start;
        j=end;

        while(i!=j){
            //j向左移动，找到第一个小于等于基准数的数字，直到j和i碰头
            while (arr[j]>=flag && i<j) {
                j--;
            }
            //i向右移动，找到第一个大于等于基准数的数字，直到i和j碰头
            while(arr[i]<=flag && i<j){
                i++;
            }

            //交换这两个数字
            if(i<j){
                int tmp=arr[i];
                arr[i]=arr[j];
                arr[j]=tmp;
            }
        }

        //最后基准数字和两个哨兵碰头的数字进行交换，交换后的基准数字左边的都是小的数字，右边都是大的数字
        arr[start]=arr[i];
        arr[i]=flag;

        //继续处理左边的，这里是一个递归的过程
        quickSort(arr, start,i-1);
        //继续处理右边的 ，这里是一个递归的过程
        quickSort(arr, i+1,end);
    }
}
```

### 位图排序法

> 题目：一个最多包含n个正整数的文件，每个数都小于n，其中n=10^7,且所有正整数都不重复。求如何将这n个正整数升序排列。
>
> 约束：最多有1MB的内存空间可用，有充足的磁盘存储空间。

我们使用hash映射，将对应的正整数映射到位图集合中。即将正整数映射到bit集合中，每一个bit代表其映射的正整数是否存在。

比如{1，2，3，5，8，13}使用下列集合表示：

0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0

我们可以使用具有10^7位的字符串来表示这个文件。其中，当且仅当整数i在文件中存在时候，第i位为1


位图法方法：

1. 创建有个10^7位（10^7/8/1024/1024≈1MB）的字符串，并将其每一bit设置为0；
2. 读取包含正整数的文件，对每一个i，将内存中bit[i] 位设置成1.
3. 按位顺序读取字符串。当读取到bit[j] 为1时输出（int）j。


>  根据位图法演变解决以下QQ面试题目：
>
> 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中

unsign int范围为0~2^32-1(4294967295≈5*10^9) 使用位图hash对应5*10^9/8/10^3/10^3 = 625MB.

1. 我们使用625M的字符串。每一位设置为0.
2. 将40亿个unsign int 遍历一遍。使用位图法将字符串中的对应位转化为1。
3. 读取“再给一个数i” 查看bit[i] 是否为1，1则有存在，0则不存在。

## 布隆过滤器

利用布隆过滤器，可以知道某个数据在一个特别大的集合中是否存在

它的特点是：

* 只要返回数据不存在，则肯定不存在。
* 返回数据存在，只是有可能存在。

## 参考

[二叉树、前序遍历、中序遍历、后序遍历](https://www.cnblogs.com/lanhaicode/p/10358736.html)

[二叉树的高度，深度和结点计算](https://jingyan.baidu.com/article/a3761b2b7f1beb5576f9aaf7.html)

[树的基本概念以及java实现二叉树](https://blog.csdn.net/qingtian_1993/article/details/80637917)

[树的基本概念以及java实现二叉树](https://blog.csdn.net/qingtian_1993/article/details/80877487)

[如何判断一个元素在亿级数据中是否存在？](http://blog.itpub.net/31556476/viewspace-2563661/)

[详解布隆过滤器的原理、使用场景和注意事项](https://www.jianshu.com/p/2104d11ee0a2)

[编程珠玑--位图法排序](https://www.cnblogs.com/yjf512/archive/2010/11/04/1868899.html)

[常见的7种排序算法](https://blog.csdn.net/liang_gu/article/details/80627548)
