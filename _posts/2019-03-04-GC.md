---
layout: post
title:  "GC"
categories: JVM
tags:  JVM
author: 网络
---

* content
{:toc}


## 前言

从oracle官方文档出发搬运GC的基础理论知识

##  课程目录
* JVM架构
* GC







## JVM架构

JVM的主要组件(HotSopt虚拟机):

![Key JVM Hotspot Components](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide2.png)

> 当进行性能调优时，JVM的三大组件需要关注：堆，JIT，GC。
> * 堆是存放对象数据的地方，受到GC的管理
> * 大部分调优选项都跟调整堆大小、选择合适的垃圾回收器有关
> * JIT也对性能有很大影响，但是一般不需要调优

## 什么是GC？

> Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.  
> In a programming language like C, allocating and deallocating memory is a manual process. In Java, process of deallocating memory is handled automatically by the garbage collector. The basic process can be described as follows.

## GC的基本过程

* 步骤1: 标记

![marking](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide3.png)

* 步骤2: 删除

![normal deletion](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide1b.png)

* 步骤2a: 删除并压缩

![deletion with compacting](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide4.png)

为了进一步改进性能，删除未引用的对象之后还可以压缩剩余有引用的对象，将有引用的对象挪到一起，使新内存对象分配更容易、更快。

## 为什么选择分代回收？

JVM里面标记和压缩对象比较低效，分配的对象越来越多，对象列表的增长会导致GC时间越来越长。应用程序的经验分析显示，大部分对象其实都比较“短命”。

![bytes surviving](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/ObjectLifetime.gif)

## JVM代

根据上面分析出来的信息，堆被分解成很多个小块，或者叫代，年轻代、老年代、永久代

![JVM heap structure](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide5.png)

* 年轻代：新对象分配到年轻代，当年轻代满了就触发一次minorGC，充满死亡对象的年轻代会被快速回收掉，有些对象存活下来，会被转移到老年代。minorGC是一次“让世界静止(stop-the-world)”的事件，所有的线程都会停止直到minorGC操作结束。
* 老年代：老年代用来存储存活久的对象，老年代需要进行majorGC，这也是“让世界静止”的事件，所有线程必须停止等待。但因为需要回收所有存活对象，一次majorGC会更慢一些，所以要最小化majorGC行为。majorGC的时间长短会受到GC收集器的种类影响。
* 永久代（PermGen）：存储类和方法的元数据信息，包括Java SE类库的类和方法。当JVM发现class不再需要的时候会被回收。永久代在full GC中回收。
> 注: JDK8移除了永久代，取而代之的是元空间（Metaspace），类的元数据信息都被存储在native heap中，空间大小受硬件内存影响，也可以通过参数-XX:MaxMetaspaceSize=<NNN>来指定最大大小。

## GC回收的过程

我们已经知道堆被分成了多个代，那每个代的空间是如何交互的呢？

1. 首先新对象都会在年轻代中的eden空间分配

![object allocation](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide13.png)

2. 当eden空间满了，一次minorGC被触发

![filling the eden space](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide14.png)

3. 有引用的对象会被复制到survivor空间s0，然后eden空间被清除，注意这个时候对象有一个年龄，值为1

![copying referenced objects](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide6.png)

4. 下一次minorGC的时候，会将eden空间以及s0空间内有引用的对象复制到survivor空间s1，同时对象年龄+1，eden空间以及s0空间会被全部清除

![object aging](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide8.png)

5. 再下一次minorGC的时候，同样的事情会再发生一次，但是这次是eden空间以及s1空间中有引用的对象会被复制到s0，同时对象年龄+1，eden空间以及s1空间会被全部清除

![additional aging](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide9.png)

6. 就这样反复经过几次minorGC之后，有些对象的年龄会达到一定的阀值（图片示例中阀值为8，hotspot虚拟机默认是15），达到阀值的对象会被提升到老年代中

![promotion](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide7.png)

7. 随着minorGC不断的进行，老年代的空间不断有新的对象增加

![promotion](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide10.png)

8. 最终老年代会进行一次majorGC，标记-清除+压缩老年代的空间

![GC process summary](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide11.png)

## GC直观体验

通过jdk自带的visual vm工具可以直观的看到一个java进程的GC分代回收的情况

```
C:\Java\jdk1.8.0_172\bin>jvisualvm
选择工具>插件
安装Visual GC插件
右击java应用打开，右侧选择Visual GC
```

![java visual vm](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/visualvm/Java2Demo03.png)

##垃圾收集器介绍

### 常用的堆相关的命令

| Switch          | Description                                         |
| --------------- | --------------------------------------------------- |
| -Xms            | Sets the initial heap size for when the JVM starts. |
| -Xmx            | Sets the maximum heap size.                         |
| -Xmn            | Sets the size of the Young Generation.              |
| -XX:PermSize    | Sets the starting size of the Permanent Generation. |
| -XX:MaxPermSize | Sets the maximum size of the Permanent Generation   |

### Serial GC

client模式应用默认使用的垃圾收集器，适用于不要求低延时低停顿时间的应用

启用命令
```
-XX:+UseSerialGC

java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar
```

### Parallel GC

多线程的方式来进行垃圾回收，默认线程数为CPU核心数，也可以通过命令来制定线程数

```
-XX:ParallelGCThreads=<desired number>
```

启用命令

```
-XX:+UseParallelGC
启用这个命令，年轻代会使用并行垃圾回收的方式，但是老年代还是单线程的方式

-XX:+UseParallelOldGC
启用这个命令年轻代和老年代都会启用多线程的垃圾回收方式
```

### Concurrent Mark Sweep (CMS)

用于老年代的回收，需要配合一个年轻代回收器一起使用。它以获取最短停顿时间为目标，基于Mark-Sweep算法，主要应用于服务端模式应用，

启用命令

```
-XX:+UseConcMarkSweepGC  //启用CMS收集器

-XX:ParallelCMSThreads=<n>  //设置线程数

Here is a sample command line for starting the Java2Demo:
java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads=2 -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar
```

### G1

Java7中开始使用，用来替换CMS收集器。它可以同时回收年轻代以及老年代。

启用命令

```
-XX:+UseG1GC

java -Xmx12m -Xms3m -XX:+UseG1GC -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar
```

### 

## 参考

[*****Java Garbage Collection Basics](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)

[Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)

[Java Platform Standard Edition 8 Documentation](https://docs.oracle.com/javase/8/docs/index.html)

[About G1 Garbage Collector, Permanent Generation and Metaspace](https://blogs.oracle.com/poonam/about-g1-garbage-collector,-permanent-generation-and-metaspace)