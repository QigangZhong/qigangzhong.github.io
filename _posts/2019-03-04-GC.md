---
layout: post
title:  "GC"
categories: JVM
tags:  JVM
author: 网络
---

* content
{:toc}


## 前言

总结JVM相关的知识

##  课程目录
* JVM堆结构







## JVM架构

JVM的主要组件(HotSopt虚拟机):

![Key JVM Hotspot Components](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide2.png)

> 当进行性能调优时，JVM的三大组件需要关注：堆，JIT，GC。
> * 堆是存放对象数据的地方，受到GC的管理
> * 大部分调优选项都跟调整堆大小、选择合适的垃圾回收器有关
> * JIT也对性能有很大影响，但是一般不需要调优

## 什么是GC？

> Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.  
> In a programming language like C, allocating and deallocating memory is a manual process. In Java, process of deallocating memory is handled automatically by the garbage collector. The basic process can be described as follows.

## GC的基本过程

* 步骤1: 标记

![marking](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide3.png)

* 步骤2: 删除

![normal deletion](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide1b.png)

* 步骤2a: 删除并压缩

![deletion with compacting](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide4.png)

为了进一步改进性能，删除未引用的对象之后还可以压缩剩余有引用的对象，将有引用的对象挪到一起，使新内存对象分配更容易、更快。

## 为什么选择分代回收？

JVM里面标记和压缩对象比较低效，分配的对象越来越多，对象列表的增长会导致GC时间越来越长。应用程序的经验分析显示，大部分对象其实都比较“短命”。

![bytes surviving](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/ObjectLifetime.gif)

## JVM代

根据上面分析出来的信息，堆被分解成很多个小块，或者叫代，年轻代、老年代、永久代

![JVM heap structure](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide5.png)

* 年轻代：新对象分配到年轻代，当年轻代满了就出发一次minor GC，充满死亡对象的年轻代会被快速回收掉，有些对象存活下来，会被转移到老年代。minor GC是一次“让世界静止”的事件，所有的线程都会停止直到minor GC操作结束。
* 老年代：老年代用来存储存活久的对象，老年代需要进行major GC，这也是“让世界静止”的事件，所有线程必须停止等待。但因为需要回收所有存活对象，一次major GC会更慢一些，所以要最小化major GC行为。major GC的时间长短会受到GC收集器的种类影响。
* 永久代（PermGen）：存储类和方法的元数据信息，包括Java SE类库的类和方法。当JVM发现class不再需要的时候会被回收。永久代在full GC中回收。
> 注: JDK8移除了永久代，取而代之的是元空间（Metaspace），类的元数据信息都被存储在native heap中，空间大小受硬件内存影响，也可以通过参数-XX:MaxMetaspaceSize=<NNN>来指定最大大小。

## GC回收的过程

...

## 参考

[*****Java Garbage Collection Basics](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)

[Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)

[Java Platform Standard Edition 8 Documentation](https://docs.oracle.com/javase/8/docs/index.html)

[About G1 Garbage Collector, Permanent Generation and Metaspace](https://blogs.oracle.com/poonam/about-g1-garbage-collector,-permanent-generation-and-metaspace)