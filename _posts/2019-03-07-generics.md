---
layout: post
title:  "Generics"
categories: java-basics
tags:  java-basics
author: 网络
---

* content
{:toc}


## 前言


总结java泛型相关知识点

##  课程目录

泛型基础知识









## 泛型介绍

Java的泛型是伪泛型，在编译之前可以帮助开发人员进行类型检查，但是在编译之后的java字节码中具体的类型信息都会被擦除掉，JVM看到的java字节码中的实际类型其实都是泛型参数对应的基类信息。

```java
List<String> list1=new ArrayList<String>();
list1.add("abc");
List<Integer> list2=new ArrayList<Integer>();
list2.add(123);
//返回结果true
System.out.println(list1.getClass()==list2.getClass());

List<Integer> list3=new ArrayList<Integer>();
list3.add(1);
//通过反射可以存储非Integer类型的数据
list3.getClass().getMethod("add", Object.class).invoke(list3, "abc");
for (int i=0;i<list3.size();i++) {
    System.out.println(list3.get(i));
}
```

例如上面的例子，会打印出true，原因是List<String>、List<Integer>对于JVM看到的都是List<Object>，String和Integer都被编译器“类型擦除”了，编译后的字节码中只保留了`原始类型(在字节码中的类型变量的真正类型)`Object。在获取值的时候，编译后的代码中自动加入了强制类型转换。

泛型类型变量不能是基本类型，只能是包装类型。例如List<Integer>是可以的，但是List<int>是非法的。

## 泛型种类

泛型参数可以用在类、接口、方法上，分别成为泛型类、泛型接口、泛型方法

### 1. 泛型类

类型参数放在类名称后面

类型参数不可以实例化

不能声明参数化类型的数组
```java
Pair<String>[] pairList=new Pair<String>[10]; //报错：创建泛型数组
```


### 2. 泛型接口

类型参数放在接口名称后面

### 3. 泛型方法

类型参数放在方法签名中返回类型前面

```java
public static void main(String[] args) {  
    /**不指定泛型的时候，泛型变量的类型为该方法中的几种类型的同一个父类的最小级，直到Object*/  
    int i=Test2.add(1, 2); //这两个参数都是Integer，所以T为Integer类型  
    Number f=Test2.add(1, 1.2);//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  
    Object o=Test2.add(1, "asd");//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  

    /**指定泛型的时候，该方法中的几种类型必须是该泛型实例类型或者其子类*/  
    int a=Test2.<Integer>add(1, 2);//指定了Integer，所以只能为Integer类型或者其子类  
    int b=Test2.<Integer>add(1, 2.2);//编译错误，指定了Integer，不能为Float  
    Number c=Test2.<Number>add(1, 2.2); //指定为Number，所以可以为Integer和Float  
}
 
public static <T> T add(T x,T y){  
    return y;  
}
```

泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数

```java
public class Test2<T> {
    public static T one;   //编译错误
    public static  T show(T one){ //编译错误
        return null;    
    }  
}


public class Test2<T> {
    //这是正确的
    //因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的T，而不是泛型类中的T
    public static <T> T show(T one){
        return null;    
    }
}
```

## 泛型约束

对类型参数实现接口或者继承某个基类的约束方式：
* 多个约束用&连接
* 继承的基类必须放在第一个位置，接口放在后面

```java
public static <T extends Object&Comparable&Serializable> T get(T t1,T t2) {
	if(t1.compareTo(t2)>=0){
        return t1;
    }
	return t2;  
}
```

### PECS原则

生产者（Producer）使用extends，消费者（Consumer）使用super。



## 参考

[The Java™ Tutorials -- Generics](https://docs.oracle.com/javase/tutorial/extra/generics/index.html)

[java 泛型详解](https://blog.csdn.net/s10461/article/details/53941091)

[java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题](https://www.cnblogs.com/shangxiaofei/p/3848500.html)