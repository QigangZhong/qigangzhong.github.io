---
layout: post
title: "MySql知识点"
categories: db mysql
tags: mysql
author: 刚子
---

* content
{:toc}

总结MySql的知识点











## 安装

### centos7通过yum方式安装mysql5.7

```bash
# 下载安装mysql官方yum源
wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
yum -y install mysql57-community-release-el7-10.noarch.rpm
# 安装mysql
yum -y install mysql-community-server

# 启动
systemctl start mysqld.service
systemctl status mysqld.service

# 从日志查询初始root密码
grep "password" /var/log/mysqld.log
# 使用root账号登陆
mysql -uroot -p

# 默认情况下重置root密码是有密码强度校验规则的，为了测试，我们先禁用密码强度、长度校验
set global validate_password_policy=0;
set global validate_password_length=1;

# 重置root账号密码
ALTER USER 'root'@'localhost' IDENTIFIED BY 'root';
# 查看密码强度校验设置
SHOW VARIABLES LIKE 'validate_password%';

# 允许外网访问本数据库
grant all privileges on *.* to 'root'@'%' identified by 'root';

# 查看数据库的存储引擎，默认InnoDB
show variables like '%storage_engine%';
```

## 基础知识点

### 索引

#### 索引的种类

* 唯一索引

添加唯一索引的列不可以有重复值，如果是组合索引那组合索引必须唯一，唯一索引列允许null值。

```bash
# 单列唯一索引
ALTER TABLE table_name ADD UNIQUE (column);
# 组合唯一索引
ALTER TABLE table_name ADD UNIQUE (column1,column2);
```

* 主键索引

主键索引是特殊的唯一索引，不允许null值，一个表只能有一个。

```bash
# 创建表的时候创建主键
CREATE TABLE table_name ( [...], PRIMARY KEY (column) );
# 给已存在的表添加主键索引
ALTER TABLE table_name ADD PRIMARY KEY (column);
```

* 普通索引

```bash
# 单列索引
ALTER TABLE table_name ADD INDEX index_name (column);
# 组合索引
ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);
```

* 全文索引

全文索引可以在VARCHAR或者TEXT类型的列上创建。

```bash
ALTER TABLE table_name ADD FULLTEXT (column);
```

> 索引不能修改，只能删除重建：
>
> ```bash
> SHOW INDEX FROM table_name;
> DROP INDEX index_name ON table_name;
> ```

#### 聚集索引、非聚集索引

* 聚集索引指的是索引的逻辑顺序和数据物理存放地址的顺序是一致的

一个表有主键的话，主键索引就是聚集索引，如果没有主键索引，该表的第一个唯一非空索引会被作为聚集索引，如果既没有主键也没有唯一非空索引，InnoDB会生成一个隐藏主键作为聚集索引，InnoDB会为每个表都增加一个聚集索引。

* 非聚集索引指的是索引的逻辑顺序与数据物理存放地址的顺序不一致

除去聚集索引以外的索引都是非聚集索引。

#### 索引的设计原则

#### 使用索引时的注意事项

1. MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。在使用关键字‘like’查询时：like ‘n%’ 走索引；但是like ‘%n%’不走索引，即有且仅有后面带上%时走索引。

2. 使用函数时索引不生效。

3. 最左前缀（Leftmost Prefixing）原则：在创建组合索引时（例如col1，col2，col3），搜索条件具有这些情形的都会使用该组合索引（col1，col2，col3或col1，col2或col1），相当于是创建了三个索引（col1，col2，col3或col1，col2或col1）。

4. 使用EXPLAIN命令可以分析SQL索引

```sql
EXPLAIN select * from user where first_name like 'a%'
```

5. 索引会占用磁盘空间，索引会降低数据更新操作的速度

### 事务隔离级别

```sql
-- 查看当前数据库的事务隔离级别
SHOW VARIABLES LIKE "%tx_isolation%"
```

#### 事务的特性

* 原子性

事务是一个原子操作单元，事务中包含的所有操作要么都做，要么都不做，没有第三种情况。

* 一致性

事务操作前和操作后都必须满足业务规则约束，比如说A向B转账，转账前和转账后AB两个账户的总金额必须是一致的。

* 隔离性

隔离性是数据库允许多个并发事务同时对数据进行读写的能力，隔离性可以防止事务并发执行时由于交叉执行导致数据不一致的问题。

* 持久性

事务完成后，对数据的修改是永久的，即使出现系统故障也不会丢失。

#### 多个事务并发访问产生的问题

* 更新丢失

当两个事务选择同一行，然后更新数据，由于每个事务都不知道其他事务的存在，就会发生丢失更新的问题，（你我同时读取同一行数据，进行修改，你commit之后我也commit，那么我的结果将会覆盖掉你的结果）。

* 脏读

一个事务正在对一条记录做修改，在这个事务提交之前，别的事务读取到了这个事务修改之后的数据，也就是说，一个事务读取到了其他事务还没有提交的数据，就叫做脏读。

* 不可重复读

一个事务读某条数据读两遍，读到的是不一样的数据，也就是说，一个事务在进行中读取到了其他事务对旧数据的修改结果，（比如说 我开一个事务 修改某条数据 先查后改 执行修改动作的时候发现这条数据已经被别的事务删掉了）

* 幻读

一个事务中，读取到了其他事务新增的数据，仿佛出现了幻象。（幻读与不可重复读类似，不可重复读是读到了其他事务update/delete的结果，幻读是读到了其他事务insert的结果）

#### 隔离级别

* read-uncommitted（生产不能使用这个级别）

在一个事务中，可以读取到其他事务未提交的数据变化，这种读取其他会话还没提交的事务，叫做脏读现象，在生产环境中切勿使用。

* read-committed

在一个事务中，可以读取到其他事务已经提交的数据变化，这种读取也就叫做不可重复读，因为两次同样的查询可能会得到不一样的结果。

* repetable-read

MySQL默认隔离级别，在一个事务中，直到事务结束前，都可以反复读取到事务刚开始时看到的数据，并一直不会发生变化，避免了脏读、不可重复读现象，但是它还是无法解决幻读问题。

* serializable

这是最高的隔离级别，它强制事务串行执行，避免了前面说的幻读现象，简单来说，它会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁争用问题。

| 隔离级别 | 读数据一致性                     | 脏读 | 不可重复读 | 幻读 |
| -------- | -------------------------------------- | ---- | ---------- | ---- |
| 未提交读 | 最低级别，只保证不读取物理上损坏的数据 | 有  | 有        | 有  |
| 已提交读 | 语句级                              | 无  | 有        | 有  |
| 可重复读 | 事务级                              | 无  | 无        | 有  |
| 可串行化 | 最高级别，事务级               | 无  | 无        | 无  |

### 锁

### 字符集、排序规则

### 常用函数

## 查询性能优化

### SQL语句优化

* `exist`替换`in`，`not exist`替换`not in`
* 查询单条数据添加limit 1

## 分库分表、mycat、sharding-jdbc

## 参考

[MySQL 隔离级别](https://www.cnblogs.com/fengyumeng/p/9852735.html)
