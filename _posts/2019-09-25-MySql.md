---
layout: post
title: "MySql知识点"
categories: db mysql
tags: mysql
author: 刚子
---

* content
{:toc}

总结MySql的知识点











## 安装

### centos7通过yum方式安装mysql5.7

```bash
# 下载安装mysql官方yum源
wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
yum -y install mysql57-community-release-el7-10.noarch.rpm
# 安装mysql
yum -y install mysql-community-server

# 启动
systemctl start mysqld.service
systemctl status mysqld.service

# 从日志查询初始root密码
grep "password" /var/log/mysqld.log
# 使用root账号登陆
mysql -uroot -p

# 默认情况下重置root密码是有密码强度校验规则的，为了测试，我们先禁用密码强度、长度校验
set global validate_password_policy=0;
set global validate_password_length=1;

# 重置root账号密码
ALTER USER 'root'@'localhost' IDENTIFIED BY 'root';
# 查看密码强度校验设置
SHOW VARIABLES LIKE 'validate_password%';

# 允许外网访问本数据库
grant all privileges on *.* to 'root'@'%' identified by 'root';
```

## 基础知识点

### 存储引擎

```sql
-- 查看mysql提供的所有存储引擎
show engines;
-- 查看数据库的存储引擎，默认InnoDB
show variables like '%storage_engine%';
-- 查看表的存储引擎
show table status like "table_name";
```

mysql5.5版本开始默认的存储引擎是InnoDB，之前是MyISAM，MyISAM和InnoDB的主要区别：

* InnoDB支持表级锁、行级锁，默认为行级锁（命中索引才会生效），MyISAM仅支持表级锁。

  > 大量update和insert操作的时候InnoDB操作效率高，而MyISAM更适合查多写少的情况。

* InnoDB支持事务、支持崩溃后安全恢复，MyISAM不支持
* InnoDB支持外键，MyISAM不支持外键

### 索引

#### 索引的种类

* 唯一索引

添加唯一索引的列不可以有重复值，如果是组合索引那组合索引必须唯一，唯一索引列允许null值。

```bash
# 单列唯一索引
ALTER TABLE table_name ADD UNIQUE (column);
# 组合唯一索引
ALTER TABLE table_name ADD UNIQUE (column1,column2);
```

* 主键索引

主键索引是特殊的唯一索引，不允许null值，一个表只能有一个。

```bash
# 创建表的时候创建主键
CREATE TABLE table_name ( [...], PRIMARY KEY (column) );
# 给已存在的表添加主键索引
ALTER TABLE table_name ADD PRIMARY KEY (column);
```

* 普通索引

```bash
# 单列索引
ALTER TABLE table_name ADD INDEX index_name (column);
# 组合索引
ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);
```

* 全文索引

全文索引可以在VARCHAR或者TEXT类型的列上创建。

```bash
ALTER TABLE table_name ADD FULLTEXT (column);
```

> 索引不能修改，只能删除重建：
>
> ```bash
> SHOW INDEX FROM table_name;
> DROP INDEX index_name ON table_name;
> ```

#### 聚集索引、非聚集索引

* 聚集索引指的是索引的逻辑顺序和数据物理存放地址的顺序是一致的

一个表有主键的话，主键索引就是聚集索引，如果没有主键索引，该表的第一个唯一非空索引会被作为聚集索引，如果既没有主键也没有唯一非空索引，InnoDB会生成一个隐藏主键作为聚集索引，InnoDB会为每个表都增加一个聚集索引。

* 非聚集索引指的是索引的逻辑顺序与数据物理存放地址的顺序不一致

除去聚集索引以外的索引都是非聚集索引。

#### 索引的设计原则

#### 使用索引时的注意事项

1. MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。在使用关键字‘like’查询时：like ‘n%’ 走索引；但是like ‘%n%’不走索引，即有且仅有后面带上%时走索引。

2. 使用函数时索引不生效。

3. 最左前缀（Leftmost Prefixing）原则：在创建组合索引时（例如col1，col2，col3），搜索条件具有这些情形的都会使用该组合索引（col1，col2，col3或col1，col2或col1），相当于是创建了三个索引（col1，col2，col3或col1，col2或col1）。

4. 使用EXPLAIN命令可以分析SQL索引

```sql
EXPLAIN select * from user where first_name like 'a%'
```

5. 索引会占用磁盘空间，索引会降低数据更新操作的速度

### 事务隔离级别

```sql
-- 查看当前数据库的事务隔离级别
SHOW VARIABLES LIKE "%tx_isolation%"
```

#### 事务的特性

事务的ACID属性：atomicity,consistent,isolation,durable

* 原子性atomicity

事务是一个原子操作单元，事务中包含的所有操作要么都做，要么都不做，没有第三种情况。

* 一致性consistent

事务操作前和操作后都必须满足业务规则约束，比如说A向B转账，转账前和转账后AB两个账户的总金额必须是一致的。

* 隔离性isolation

隔离性是数据库允许多个并发事务同时对数据进行读写的能力，隔离性可以防止事务并发执行时由于交叉执行导致数据不一致的问题。

* 持久性durable

事务完成后，对数据的修改是永久的，即使出现系统故障也不会丢失。

#### 多个事务并发访问产生的问题

* 更新丢失

当两个事务选择同一行，然后更新数据，由于每个事务都不知道其他事务的存在，就会发生丢失更新的问题，（你我同时读取同一行数据，进行修改，你commit之后我也commit，那么我的结果将会覆盖掉你的结果）。

* 脏读

一个事务正在对一条记录做修改，在这个事务提交之前，别的事务读取到了这个事务修改之后的数据，也就是说，一个事务读取到了其他事务还没有提交的数据，就叫做脏读。

* 不可重复读

一个事务读某条数据读两遍，读到的是不一样的数据，也就是说，一个事务在进行中读取到了其他事务对旧数据的修改结果，（比如说 我开一个事务 修改某条数据 先查后改 执行修改动作的时候发现这条数据已经被别的事务删掉了）

* 幻读

一个事务中，读取到了其他事务新增的数据，仿佛出现了幻象。（幻读与不可重复读类似，不可重复读是读到了其他事务update/delete的结果，幻读是读到了其他事务insert的结果）

#### 隔离级别

* read-uncommitted（生产不能使用这个级别）

在一个事务中，可以读取到其他事务未提交的数据变化，这种读取其他会话还没提交的事务，叫做脏读现象，在生产环境中切勿使用。

* read-committed

在一个事务中，可以读取到其他事务已经提交的数据变化，这种读取也就叫做不可重复读，因为两次同样的查询可能会得到不一样的结果。

* repetable-read

MySQL默认隔离级别，在一个事务中，直到事务结束前，都可以反复读取到事务刚开始时看到的数据，并一直不会发生变化，避免了脏读、不可重复读现象，但是它还是无法解决幻读问题。

* serializable

这是最高的隔离级别，它强制事务串行执行，避免了前面说的幻读现象，简单来说，它会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁争用问题。

| 隔离级别 | 读数据一致性                     | 脏读 | 不可重复读 | 幻读 |
| -------- | -------------------------------------- | ---- | ---------- | ---- |
| 未提交读 | 最低级别，只保证不读取物理上损坏的数据 | 有  | 有        | 有  |
| 已提交读 | 语句级                              | 无  | 有        | 有  |
| 可重复读 | 事务级                              | 无  | 无        | 有  |
| 可串行化 | 最高级别，事务级               | 无  | 无        | 无  |

### 锁

#### 锁的介绍

##### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

多写的场景下用悲观锁就比较合适。

##### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。乐观锁一般会使用版本号机制或CAS算法实现。

* 版本号机制

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

* CAS(compare and swap)

无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数：

需要读写的内存值 V

进行比较的值 A

拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

#### 共享锁（读锁）

#### 排它锁（写锁）

### 字符集、排序规则

### 常用函数

## 查询性能优化

### SQL语句优化

* [exists与in的区别](https://github.com/QigangZhong/qigangzhong.github.io/blob/master/articles/db/mysql-exists-in.md)
* 查询单条数据添加`limit 1`

## 分库分表、mycat、sharding-jdbc

## 参考

[MySQL 隔离级别](https://www.cnblogs.com/fengyumeng/p/9852735.html)
